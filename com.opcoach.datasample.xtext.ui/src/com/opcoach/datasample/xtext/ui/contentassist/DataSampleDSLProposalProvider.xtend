/*
 * generated by Xtext
 */
package com.opcoach.datasample.xtext.ui.contentassist

import com.opcoach.datasample.AssociationGenerator
import com.opcoach.datasample.ChildrenGenerator
import com.opcoach.datasample.DataSample
import com.opcoach.datasample.DataSampleUtil
import com.opcoach.datasample.EntityGenerator
import com.opcoach.datasample.FieldGenerator
import com.opcoach.generator.basic.BooleanGenerator
import com.opcoach.generator.basic.DateGenerator
import com.opcoach.generator.basic.DoubleGenerator
import com.opcoach.generator.basic.FalseGenerator
import com.opcoach.generator.basic.FloatGenerator
import com.opcoach.generator.basic.IDGenerator
import com.opcoach.generator.basic.IntGenerator
import com.opcoach.generator.basic.LongGenerator
import com.opcoach.generator.basic.NullValueGenerator
import com.opcoach.generator.basic.StringGenerator
import com.opcoach.generator.basic.TrueGenerator
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor

/**
 * see http://www.eclipse.org/Xtext/documentation.html#contentAssist on how to customize content assistant
 */
class DataSampleDSLProposalProvider extends AbstractDataSampleDSLProposalProvider {

// Expect any kind of package URI...
	override completeDataSample_PackageURI(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		super.completeDataSample_PackageURI(model, assignment, context, acceptor)

		// Get all registry packages available in platform
		for (k : EPackage.Registry.INSTANCE.keySet)
			acceptor.accept(createCompletionProposal(k, context))

	}

	override completeDataSample_RootEntityName(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		// super.completeDataSample_RootEntityName(model, assignment, context, acceptor)
		val ds = model as DataSample
		val pack = EPackage.Registry.INSTANCE.getEPackage(ds.packageURI)

		if (pack !== null)
			for (c : pack.EClassifiers.filter(EClass))
				acceptor.accept(createCompletionProposal(c.name, context))
		else
			acceptor.accept(createCompletionProposal("No package found for this URI", context))

	}

	/* 	override completeDataSample_BadValueGeneratorNames(EObject model, Assignment assignment,
	 * 		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
	 * 		super.completeDataSample_BadValueGeneratorNames(model, assignment, context, acceptor)

	 * 		for (c : availableGenerators)
	 * 			acceptor.accept(createCompletionProposal(c.name, context))
	 } */
// This is expected in :   generate XXX Customer for instance
// Customer must be proposed once if contained in package
	override completeEntityGenerator_EntityName(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {

		// EntityGenerator is may be at first level or inside another EntityGenerator. 
		val egen = model as EntityGenerator
		if (egen.eContainer instanceof DataSample) {
			// This is the root Entity Generator, only the root entityName object is possible
			val ds = egen.eContainer as DataSample
			acceptor.accept(createCompletionProposal(ds.rootEntityName, context))
		} else {
			// This entity generator is already inside another one, it can be another EntityGenerator or a childrenGenerator
			val List<String> egenSibling = new ArrayList // Define the sibling of this entity generator. 
			var EClass parentClass = null

			val egparent = egen.eContainer
			if (egparent instanceof EntityGenerator) {
				val parent = egparent as EntityGenerator
				parentClass = parent.entity

			} else {
				// This is a children generator
				if (egparent instanceof ChildrenGenerator) {
					val pcg = egparent as ChildrenGenerator
					parentClass = pcg.EReference.EType as EClass
					for (cg : pcg.childrenGenerators)
					   egenSibling.add(cg.entityName)

				}
			}

			// Must get all children classes of parentClass without the current siblings
			if (parentClass !== null) {
				if (! parentClass.isAbstract)
					acceptor.accept(createCompletionProposal(parentClass.name, context))

				for (c : DataSampleUtil.getSubClasses(parentClass)) {
					if (!egenSibling.contains(c.name))
						acceptor.accept(createCompletionProposal(c.name, context))
				}
			}
		}

	}

	override completeAssociationGenerator_FieldName(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val ag = model as AssociationGenerator
		val egen = ag.eContainer as EntityGenerator
		val c = egen.entity
		val List<String> egenSibling = new ArrayList // Define the sibling of this entity generator. 
		egen.associationGenerators.forEach[if(fieldName !== null) egenSibling.add(fieldName)]

		for (r : c.EAllReferences.filter[!containment && (!isDerived)]) {
			if (!egenSibling.contains(r.name))
				acceptor.accept(createCompletionProposal(r.name, context))
		}

	}

	override completeChildrenGenerator_FieldName(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val cg = model as ChildrenGenerator
		val egen = cg.eContainer as EntityGenerator
		val c = egen.entity
		val List<String> egenSibling = new ArrayList // Define the sibling of this entity generator. 
		egen.childGenerators.forEach[if(fieldName !== null) egenSibling.add(fieldName)]

		// Keep only composition with concrete types
		for (r : c.EAllReferences.filter[containment]) // .filter[!EReferenceType.abstract]) 
		{
			if (!egenSibling.contains(r.name))
				acceptor.accept(createCompletionProposal(r.name, context))
		}

	}


	// Must propose only fields of current class (but only once)
	override completeFieldGenerator_FieldName(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		super.completeFieldGenerator_FieldName(model, assignment, context, acceptor)

		// Must propose only EClass whose name is not yet selected
		// Must iterate in all packages
		val currentField = (model as FieldGenerator)
		val epack = currentField.EPackage

		// Get all name already used for this entity...
		val ds = model.eContainer as EntityGenerator // Voir comment le récupérer vu que c'est l'objet root
		val presentNames = ds.fieldGenerators.map([fieldName])
		// for (e : currentEntity.fieldGenerators)
		// if (e.entityName.equals(currentField.entityName))
		// presentNames.add(e.fieldName)
		// For all EStructuralFeature defined in EClass, keep only those not yet used
		val EClass ecl = epack.eAllContents.filter(EClass).filter[it.name.equals(ds.entityName)].head
		for (sf : ecl.EAllAttributes.toList)
			if (!presentNames.contains(sf.name))
				acceptor.accept(createCompletionProposal(sf.name, context))

	}

	// Propose only parameters available for generators. 
	var String[] parameterList = #["locale", "seed", "low", "high", "step"]

	override completeParameter_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val fgen = model as FieldGenerator
		val parametersInFg = fgen.parameters.map[name]
		for (s : parameterList)
			if (!parametersInFg.contains(s))
				acceptor.accept(createCompletionProposal(s, context))
	}

	override completeAssociationGenerator_GeneratorName(EObject model, Assignment assignment,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		val ag = model as AssociationGenerator
		val egen = ag.eContainer as EntityGenerator
		// Search for the corresponding structural feature in ENtity. 
		val eclass = egen.entity
		val ref = eclass.EAllReferences.filter[!containment && !(derived)].filter[name == ag.fieldName].get(0)
		for (g : ref.availableGenerators) {
			val fullName = g.name
			val pos = fullName.lastIndexOf('.')
			acceptor.accept(createCompletionProposal(g.name.substring(pos + 1), context))

		}

	}

	override completeFieldGenerator_GeneratorName(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val fg = model as FieldGenerator
		val egen = fg.eContainer as EntityGenerator
		// Search for the corresponding structural feature in ENtity. 
		val eclass = egen.entity
		val att = eclass.EAllAttributes.filter[name == fg.fieldName].get(0)
		if (att !== null)
			for (g : att.availableGenerators) {
				val fullName = g.name
				val pos = fullName.lastIndexOf('.')
				acceptor.accept(createCompletionProposal(g.name.substring(pos + 1), context))

			}
	}

	/* 	override completeChildrenGenerator_GeneratorName(EObject model, Assignment assignment, ContentAssistContext context,
	 * 		ICompletionProposalAcceptor acceptor) {
	 * 		val cg = model as ChildrenGenerator
	 * 		val egen = cg.eContainer as EntityGenerator
	 * 		// Search for the corresponding structural feature in ENtity. 
	 * 		val eclass = egen.entity
	 * 		val ref = eclass.EAllReferences.filter[containment && !(derived)].filter[name == cg.fieldName].get(0)
	 * 		for (g : ref.availableGenerators) {
	 * 			val fullName = g.name
	 * 			val pos = fullName.lastIndexOf('.')
	 * 			acceptor.accept(createCompletionProposal(g.name.substring(pos + 1), context))

	 * 		}
	 } */
	// May be this init should be elsewhere...
	var Map<String, Set<Class<?>>> generators

	def getAvailableGenerators(EStructuralFeature f) {
		var Set<Class<?>> result = null
		if (generators === null) {
			generators = new HashMap

			generators.put("EString", #{StringGenerator, IDGenerator})
			generators.put("EInt", #{IntGenerator})
			generators.put("EBoolean", #{BooleanGenerator, TrueGenerator, FalseGenerator})
			generators.put("EBooleanObject", #{BooleanGenerator, TrueGenerator, FalseGenerator, NullValueGenerator})
			generators.put("EDate", #{DateGenerator, NullValueGenerator})
			generators.put("EDouble", #{DoubleGenerator})
			generators.put("EDoubleObject", #{DoubleGenerator, NullValueGenerator})
			generators.put("EFloat", #{FloatGenerator})
			generators.put("EFloatObject", #{FloatGenerator, NullValueGenerator})
			generators.put("ELong", #{LongGenerator})
			generators.put("ELongObject", #{LongGenerator, NullValueGenerator})
			generators.put("EObject", #{NullValueGenerator})
			generators.put("EJavaObject", #{NullValueGenerator})
			generators.put("EDataType", #{NullValueGenerator})
		}

		if (f instanceof EAttribute)
			result = generators.get(f.EType.name)
		else {
			// This is a reference
			val r = f as EReference
			if (r.isContainment) {
				result = #{ChildrenGenerator}

			} else
				result = #{AssociationGenerator}
		}

		if (result === null)
			#{}
		else
			result

	// A ETUDIER
	// Must check how to get all classes that extends ValueGenerator, 
	// Or must use an extension point. 
	/*val valgen = ValueGenerator 
	 * for (i : valgen.genericInterfaces)
	 * println("Interface : " + i)
	 * 
	 * println("Package name : " + Reflection.getPackageName(ValueGenerator))
	 * val c = ClassPath.from(ValueGenerator.classLoader)
	 * // val list = c.topLevelClasses
	 * val list = Instrumentation.
	 * println("Size for list of top level : " + list.size)
	 * for (ac : list  )
	 *   	println("Classe : " + ac.name)
	 *   	
	 *   	
	 *  for ( tt : TypeToken.of(ValueGenerator).types)
	 *  println("tt : " + tt.type.typeName)
	 */
	/* 	val region= JavaCore.newRegion
	 * 	region.add(IJavaEl)
	 * 	ITypeHierarchy hierarchy= JavaCore.newTypeHierarchy(region, null, new SubProgressMonitor(pm, 1));
	 * 	IType[] allClasses= hierarchy.getAllClasses();
	 */
	}

	// Compute the EPackage from an EntityGenerator
	def getEPackage(EntityGenerator egen) {
		getEPackage(egen.dataSample)
	}

	// Compute the EPackage from a FieldGenerator
	def getEPackage(FieldGenerator fgen) {
		getEPackage(fgen.dataSample)
	}

	// Compute the EPackage from the root object
	def getEPackage(DataSample ds) {
		EPackage.Registry.INSTANCE.getEPackage(ds.packageURI)
	}

}
