/*
 * generated by Xtext
 */
package com.opcoach.datasample.xtext.ui.contentassist

import com.opcoach.datasample.AssociationGenerator
import com.opcoach.datasample.ChildrenGenerator
import com.opcoach.datasample.DataSample
import com.opcoach.datasample.DataSampleUtil
import com.opcoach.datasample.EntityGenerator
import com.opcoach.datasample.FieldGenerator
import com.opcoach.generator.basic.IntGenerator
import com.opcoach.generator.basic.StringGenerator
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Map
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EPackage
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor

/**
 * see http://www.eclipse.org/Xtext/documentation.html#contentAssist on how to customize content assistant
 */
class DataSampleDSLProposalProvider extends AbstractDataSampleDSLProposalProvider {

	// Expect any kind of package URI...
	override completeDataSample_PackageURI(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		super.completeDataSample_PackageURI(model, assignment, context, acceptor)

		// Get all registry packages available in platform
		for (k : EPackage.Registry.INSTANCE.keySet)
			acceptor.accept(createCompletionProposal(k, context))

	}

	override completeDataSample_RootEntityName(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		// super.completeDataSample_RootEntityName(model, assignment, context, acceptor)
		val ds = model as DataSample
		val pack = EPackage.Registry.INSTANCE.get(ds.packageURI) as EPackage
		for (c : pack.EClassifiers.filter(EClass))
			acceptor.accept(createCompletionProposal(c.name, context))

	}

	/* 	override completeDataSample_BadValueGeneratorNames(EObject model, Assignment assignment,
	 * 		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
	 * 		super.completeDataSample_BadValueGeneratorNames(model, assignment, context, acceptor)

	 * 		for (c : availableGenerators)
	 * 			acceptor.accept(createCompletionProposal(c.name, context))
	 } */
	// This is expected in :   generate XXX Customer for instance
	// Customer must be proposed once if contained in package
	override completeEntityGenerator_EntityName(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {

		// ENtityGeneraot is may be at first level or inside another EntityGenerator. 
		val egen = model as EntityGenerator
		val List<String> egenSibling = new ArrayList // Define the sibling of this entity generator. 
		var EClass parentClass = null
		if (egen.eContainer instanceof DataSample) {
			// This is the main Entity Generator, sibling are in data sample
			val ds = egen.eContainer as DataSample
			ds.entityGenerators.forEach[if(entity !== null && entity.name !== null) egenSibling.add(entity.name)]
			parentClass = ds.rootEntity
		}
		/*else {
		 * 	// This entity generator is already inside another one, must get sibling in parent/child generators
		 * 	val egparent = egen.eContainer as EntityGenerator
		 * 	egparent.childGenerators.forEach[if(entity !== null && entity.name !== null) egenSibling.add(entity.name)]
		 * 	parentClass = egparent.entity
		 }*/
		// Must get all children classes of parentClass without the current siblings
		if (parentClass !== null) {
			for (c : DataSampleUtil.getChildrenClasses(parentClass)) {
				if (!egenSibling.contains(c.name))
					acceptor.accept(createCompletionProposal(c.name, context))
			}
		}

	}

	override completeAssociationGenerator_FieldName(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val ag = model as AssociationGenerator
		val egen = ag.eContainer as EntityGenerator
		val c = egen.entity
		val List<String> egenSibling = new ArrayList // Define the sibling of this entity generator. 
		egen.associationGenerators.forEach[if(fieldName !== null) egenSibling.add(fieldName)]

		for (r : c.EAllReferences.filter[!containment && (!isDerived)]) {
			if (!egenSibling.contains(r.name))
				acceptor.accept(createCompletionProposal(r.name, context))
		}

	}

	override completeChildrenGenerator_FieldName(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val cg = model as ChildrenGenerator
		val egen = cg.eContainer as EntityGenerator
		val c = egen.entity
		val List<String> egenSibling = new ArrayList // Define the sibling of this entity generator. 
		egen.childGenerators.forEach[if(fieldName !== null) egenSibling.add(fieldName)]

		for (r : c.EAllReferences.filter[containment]) {
			if (!egenSibling.contains(r.name))
				acceptor.accept(createCompletionProposal(r.name, context))
		}

	}

	// Must propose here any kind of class in package
	/*	override completeFieldGenerator_EntityName(EObject model, Assignment assignment, ContentAssistContext context,
	 * 		ICompletionProposalAcceptor acceptor) {
	 * 		super.completeFieldGenerator_EntityName(model, assignment, context, acceptor)

	 * 		val epack = getEPackage(model as DataSample)
	 * 		for (cl : epack.eAllContents.filter(EClass).toList)
	 * 			acceptor.accept(createCompletionProposal(cl.name, context))

	 } */
	// Must propose only fields of current class (but only once)
	override completeFieldGenerator_FieldName(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		super.completeFieldGenerator_FieldName(model, assignment, context, acceptor)

		// Must propose only EClass whose name is not yet selected
		// Must iterate in all packages
		val currentField = (model as FieldGenerator)
		val epack = currentField.EPackage

		// Get all name already used for this entity...
		val ds = model.eContainer as EntityGenerator // Voir comment le récupérer vu que c'est l'objet root
		val presentNames = ds.fieldGenerators.map([fieldName])
		// for (e : currentEntity.fieldGenerators)
		// if (e.entityName.equals(currentField.entityName))
		// presentNames.add(e.fieldName)
		// For all EStructuralFeature defined in EClass, keep only those not yet used
		val EClass ecl = epack.eAllContents.filter(EClass).filter[it.name.equals(ds.entityName)].head
		for (sf : ecl.EAllAttributes.toList)
			if (!presentNames.contains(sf.name))
				acceptor.accept(createCompletionProposal(sf.name, context))

	}

	// Propose only parameters available for generators. 
	var String[] parameterList = #["locale", "seed", "low", "high", "step"]

	override completeParameter_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val fgen = model as FieldGenerator
		val parametersInFg = fgen.parameters.map[name]
		for (s : parameterList)
			if (!parametersInFg.contains(s))
				acceptor.accept(createCompletionProposal(s, context))
	}

	var Map<String, Class<?>> generators

	def getAvailableGenerators() {
		if (generators === null) {
			generators = new HashMap

			generators.put("EString", StringGenerator)
			generators.put("EInt", IntGenerator)

		}

		generators.values

	// Must check how to get all classes that extends ValueGenerator, 
	// Or must use an extension point. 
	/*val valgen = ValueGenerator 
	 * for (i : valgen.genericInterfaces)
	 * println("Interface : " + i)
	 * 
	 * println("Package name : " + Reflection.getPackageName(ValueGenerator))
	 * val c = ClassPath.from(ValueGenerator.classLoader)
	 * // val list = c.topLevelClasses
	 * val list = Instrumentation.
	 * println("Size for list of top level : " + list.size)
	 * for (ac : list  )
	 *   	println("Classe : " + ac.name)
	 *   	
	 *   	
	 *  for ( tt : TypeToken.of(ValueGenerator).types)
	 *  println("tt : " + tt.type.typeName)
	 */
	/* 	val region= JavaCore.newRegion
	 * 	region.add(IJavaEl)
	 * 	ITypeHierarchy hierarchy= JavaCore.newTypeHierarchy(region, null, new SubProgressMonitor(pm, 1));
	 * 	IType[] allClasses= hierarchy.getAllClasses();
	 */
	}

	// Compute the EPackage from an EntityGenerator
	def getEPackage(EntityGenerator egen) {
		getEPackage(egen.eContainer as DataSample)
	}

	// Compute the EPackage from a FieldGenerator
	def getEPackage(FieldGenerator fgen) {
		getEPackage(fgen.eContainer.eContainer as DataSample)
	}

	// Compute the EPackage from the root object
	def getEPackage(DataSample ds) {
		EPackage.Registry.INSTANCE.getEPackage(ds.packageURI)
	}

}
